url_for() ფუნქცია უზრუნველყოფს ლინკის დაგენერირებას. პარამეტრად გადაეცემა 
სტრიქონი,
რომელიც წარმოადგენს იმ ფუნქციის დასახელებას, რომლის შესაბამისი ლინკის 
აგებაც გვსურს.
ფუნქციას შესაძლოა გადაეცეს სხვა პარამეტრებიც, იმ შემთხვევაში თუ პირველ 
პარამეტრად
მითითენულ ფუნქცია არის პარამეტრიანი ფუნქცია, ყველა მისი პარამეტრი 
შეგვიძლია გადავცეთ
url_for()-ში მომდევნო პარამეტრებად (მაგალითი განხილულია მომდევნო 
სლაიდებზე).
✲ redirect() ფუნქცია უზრუნველყოფს პარამეტრად გადაცემულ ლინკზე გადასვლას
(გადამისამართებას).
Templates (შაბლონები) წარმოადგენს ფაილებს, რომლებიც შეიცავს სტატიკურ 
მონაცემებს და
placeholder-ებს დინამიური მონაცემებისთვის. შაბლონების დარენდერება 
ხორციელდება jinja
ბიბლიოთეკის გამოყენებით, რომ მივიღოთ საბოლოო დოკუმენტი.
✲ უმეტესად ვებ აპლიკაციებისთვის გამოიყენება html ფაილების შაბლონები და 
მათი მოთავსება ხდება
templates საქაღალდეში. საიტის თითოეულ გვერდზე მიბმული უნდა იყოს კონკრეტული 
html
გვერდი. სტატიკური Html გვერდის აგება ხდება front-end დეველოპერის მიერ, 
რომელიც back-end
დეველოპერმა უნდა „გააცოცხლოს“ და გახადოს დინამიური.
✲ მაშინ როცა html ფაილში გვსურს პითონის ცვლადების, ფუნქციების და 
ოპერაციების გამოყენება,
დაგვჭირდება jinja-ს გამოყენება. Jinja სინტაქსი ძალიან გავს პითონს. იგი 
იყენებს სპეციალურ გამყოფ
აღნიშვნებს, როგორიცაა {{ }} და {% %}. {{ }}-ში იწერება გამოსახულება, ხოლოდ 
{% %}-ში იწერება
გარკვეული ოპერაცია როგორიცაა for და if.
✲ მომდევნო სლაიდებზე იხილეთ შესაბამისი მაგალითები
საიტის რომელიმე გვერდზე html ფაილის მიბმა ხორციელდება
render_template() ფუნქციის გამოყენებით. პირველ პარამეტრად
ეთითება ფაილის სახელი, რომელიც მოთავსებული უნდა იყოს
templates საქაღალდეში.
✲ თუ html ფაილში გვსურს გამოვიყენოთ პიტონის ფაილიდან
რომელიმე ცვლადი, მათი გადაცემა ხორციელდება
render_template() ფუნქციაში მომდევნო პარამეტრებად. მაგ. user()
ფუნქციაში ხდება user.html ფაილის მიბმა და პარამეტრად
გადაეცემა name ცვლადის მნიშვნელობა, რომლის გამოყენება html
ფაილში ხდება my_name-ით (პარამეტრის სახელით)
✲ User.html ფაილში გამოყენებულია jinja სინტაქსი.
უმეტესწილად საიტის აწყობისას საიტის სხვადასხვა გვერდს აქვს ერთი დაიგივე 
კომპონენტები, მაგალითად ყველა
გვერდზე გვხვდება ერთი და იგივე header, მენიუ, ბანერი, footer, ხოლო 
ზოგიერთი ნაწილი სხვადასხვანაირია
სხვადასხვა გვერდზე.
✲ Jinja-ს ერთ-ერთი მნიშვნელოვანი ნაწილია შაბლონების დაკავშირება, რაც 
გვაძლევს იმის საშუალებას, რომ შევქმნათ
base.html (ან layout.html) ბაზისური შაბლონი, რომელიც შეიცავს საიტის ყველა 
გვერდის საერთო ნაწილებს და სადაც
შეგვიძლია განვსაზღვროთ ის ბლოკები (დასახელებები მხოლოდ) რომლებიც 
სხვადასხვა გვერდისთვის ცალ-ცალკე
უნდა განისაზღვროს.
✲ სხვა შვილობილი გვერდები (html ფაილები) აგებულია base.html-ის ბაზაზე და
ბლოკები, რომლებიც განსზღვრულია ბაზისურ ფაილში, უნდა განისაზღვროს
კონკრეტულ გვერდებზე ცალ-ცალკე.
✲ ბაზისურ ფაილში სასურველი ბლოკების განსაზღვრა ხდება შემდეგნაირად, სადაც
უნდა მიეთითოს ბლოკის სახელი და მისი დასასრული. მათ შორის შეიძლება ეწეროს
html კოდი ან იყოს ცარიელი.
✲ შვილობილ ფაილში პირველ რიგში უნდა მიეთითოს ბაზისური ფაილის
სახელწოდება შემდეგნაირად. შემდეგ კი უნდა განისაზღვროს საჭირო html ბლოკები
(რომლებიც შემოღებულია ბაზისურ ფაილში) სურვილისამებრ:
HTTP (Hypertext Transfer Protocol) წარმოადგენს საკომუნიკაციო არხს კლიენტსა 
და სერვერს შორის. იგი გულისხმობს
სერვერზე request-ის გაგზავნას და სერვერიდან response-ის მიღებას.
✲ ყველაზე ხშირად გამოყენებადი HTTP მეთოდებია: GET და POST
✲ GET გამოიყენება მაშინ, როდესაც request-ის გაგზავნა ხდება URL-ის 
მეშვეობით. შესაბამისად, URL-ში ეთითება
საჭირო პარამეტრები (პარამეტრის სახელი და მნიშნველობა). გამოიყენება ‘&’ 
სიმბოლო პარამეტრების
ერთმანეთისგან გამოსაყოფად და ‘?’ ძირითადი მისამართისა და პარამეტრების 
ერთმანეთისგან გამოსაყოფად
✲

✲ GET-ით შესაძლებელია ლიმიტირებული მონაცემების გაგზავნა სერვერზე, იგი 
რჩება ბრაუზერის history-ში,
გადაცემული ინფორმაცია ხილვადია ყველასთვის (არ გამოიყენება დაფარული 
ინფორმაციის გადასაცემად)
✲ POST გამოიყენება მონაცემების გასაგზავნად სერვერზე, რომლის შენახვა (ან 
განახლება) უნდა მოხდეს ბაზაში (ან სხვა
რესურში). POST მეთოდი გამოიყენება ფორმებში შეყვანილი ინფორმაციის სერვერზე 
გასაგზავნად.
✲ POST მეთოდის ელემენტები არ არის ხილვადი, არ ხდება მისი ქეშირება, არ 
რჩება ბრაუზერის history-ში, მისი
ელემენტების სიგრძე არ არის ლიმიტირებული.
✲ დამატებითი ინფო იხილეთ: 
https://flask.palletsprojects.com/en/1.1.x/api/#flask.Request
Flask-ში HTTP request-ებთან სამუშაოდ დაგვჭირდება request ობიექტი: from 
flask import request
✲ თუ გვსურს მოვწვდეთ url-ის ატრიბუტების მნიშვნელობას, უნდა გამოვიყენოთ 
request-ის args რომელიც წარმოდგენილია
ლექსიკონის სახით.

✲ POST მეთოდისას, ვინაიდან მონაცემების გადაცემა ხდება html ფორმის (<form> 
ტეგი) მეშვეობით, უმეტესად ფორმას აქვს submit
(დადასტურების) ღილაკი. ფორმის ელემენტებს კი აქვთ სახელები, რომლის 
მეშვეობითაც მოგვიანებით შესაძლებელია მათზე
წვდომა. დადასტურების ღილაკზე დაწკაპებისას ხდება POST request-ის გაგზავნა 
და შესაბამისად ფორმაში შეყვანილი
ელემენტებზე წვდომა პითონში შესაძლებელია ფორმის ელემენტების სახელების 
მეშვეობით, რომლებიც შენახულია form
ლექსიკონის სახით.

✲ შენიშვნა: შესაძლებელია ფორმის მეშვეობით არა მარტო POST request-ის 
არამედ, GET request-ის გაგზავნაც (URL-ის შეცვლა).
იხილეთ საკლასო სავარჯიშოები.
✲ POST მეთოდის გამოყენებისას, route-ში უნდა მიეთითოს გამოსაყენებელი http 
მეთოდის ტიპ(ებ)ი შემდეგნაირად:
ვებ აპლიკაციებთან მუშაობის დროს ხშირად საწიროა დროებითი ინფორმაციის 
გამოყენება სხვადასხვა გვერდზე.
მაგალითად, თუ მომხმარებელი გაივლის ავტორიზიაციას, მისი მონაცემები 
(username) ხელმისაწვდომი უნდა იყოს
საიტის სხვადასხვა გვერდზე და უნდა აჩვენებდეს რომ ავორტიზირებულია ყველგან. 
ესეთ შემთხვევაში იყენებენ
სესიებს (sessions). სესია ინახავს ყველა საწირო ინფორმაციას მომხარებლის 
შესახებ.
✲ Flask Session დოკუმენტაცია: 
https://flask.palletsprojects.com/en/1.1.x/api/?highlight=session#flask.session
✲ სესიების მუშაობის ხანგრძლივობა ვარიაბელურია. სესია ასრულებს მუშაობას 
(მასში შენახული ინფორმაცია იკარგება),
როცა ბრაუზერის დახურვა ხდება, საიტის დახურვისას ან ასევე წინასწარ შეიძლება 
განისაზღვროს სესიის მოქმედების
ხანგრძლივობა (მაგ. 30 დღე). თუ მომხარებლის მიერ საიტის თავიდან გახსნისას, 
კვლავ დალოგინებულია, ეს ნიშნავს
რომ რომ სესიაში ინფორმაცია შენახულია. ესეთ დროს გამოიყენება სესიის 
cookies-ში შენახვა.
✲ Flask-ში სესიების გამოსაყენებლად უნდა მოვახდინოთ შესაბამისი კომპონენტის 
დაიმპორტება შემდეგნაირად:

✲ Flask-ში სესიები წარმოადგენილია ლექსიკონის სახით. სესიის სასურველი 
მონაცემის გასაწერად ვმუშაობთ როგორც
ლექსიკონზე, შემდეგნაირად: session['user'] = user დეტალურად იხილეთ ქვემოთ 
მითითებულ ამოცანაში
SQLAlchemy წარმოადგენს ბიბლიოთეკას და ORM (object-relational mapper)-ს, 
რომელიც გამოიყენება
SQL მონაცემთა ბაზებთან სამუშაოდ სხვადასხვა ტიპის აპლიკაციებისთვის.
https://docs.sqlalchemy.org/en/13/
✲ უშუალოდ ვებ აპლიკაციებთან და flask-ში სამუშაოდ არსებობს 
Flask-SQLAlchemy ბიბლიოთეკა,
რომელიც წარმოადგენს SQLAlchemy-ის ადაპტირებულ ვერსიას და მორგებულია 
Flask-ის
აპლიკაციებთან სამუშაოდ.
✲ ინსტალაცია: pip install Flask-SQLAlchemy
✲ დოკუმენტაცია: https://flask-sqlalchemy.palletsprojects.com/en/2.x/
✲ SQLAlchemy მუშაობს შემდეგ მონაცემთა ბაზებთან: SQLite, Postgresql, 
MySQL, Oracle, MS-SQL,
Firebird, Sybase.
✲ Flask აპლიკაციაში მოდულის დაიმპორტება:
✲ თავდაპირველად უნდა განისაზღვროს ბაზასთან სამუშაო კონფიგურაციის 
ელემენტები:
SQLAlchemy წარმოადგენს ORM (object-relational mapper)-ს, რაც გულისხმობს, 
რომ ბაზასთან მუშაობა ხორციელდება ობიექტების
(კლასების) მეშვეობით. სანამ ბაზასთან სამუშაო ბრძანებებს გამოვიყენებთ, 
იმისათვის რომ მოვახდინოთ SELECT, INSERT,
UPDATE, და ა.შ, მანამდე უნდა შევქმნათ მოდელი.
✲ Sqlalchemy-ში აწერილია კლასი Model, რომელიც წარმოადგენს ბაზისურ მოდელს, 
რომელზე დაფუძნებითაც შეგვიძლია
შევქმნათ ახალი მოდელი.
✲ იხილეთ მარტივი მაგალითი დოკუმენტაციაში: 
https://flask-sqlalchemy.palletsprojects.com/en/2.x/quickstart/
✲ ყველა ცხრილისთვის, რომელთანაც გვსურს მუშაობა უნდა გაიწეროს ცალკე 
მოდელი, შემდეგნაირად:
ვებ აპლიკაციებში ხშირად საჭიროა მომხარებელს გამოუტანოს გარკვეული 
მოქმედების შემდეგ
ინფორმაცია/შეტყობინება (feedback); Flask-ში ეს საკითხი მარტივად არის 
გადაჭრილი flash-ის გამოყენებით. მისი
მეშვეობით შესაძლებელია გარკვეული მესიჯის შენახვა და მისი გამოტანა მხოლოდ 
და მხოლოდ მომდევნო request-ზე.
✲ დოკუმენტაცია: 
https://flask.palletsprojects.com/en/1.1.x/patterns/flashing/
✲ flash() ფუნქციის გამოყენებით შესაძლებელია მესიჯის დამახსოვრება მომდევნო 
გვერდზე დაგასვლისას. ფუნქციაში
მეორე პარამეტრად შეგვიზლია მივუთითოთ კატეგორიის სახელწოდება (მაგ. ‘error’, 
‘info’, ‘warning’, ან ნებისმიერი სხვა
სახელწოდება სურვილისამებრ). შენიშვნა: გაითვალისწინეთ, flask მოდულიდან უნდა 
დააიმპორტოთ flash ფუნქცია

✲ {% with var1=value %} - with ოპერაცია წარმოადგენს ცვლადის განსაზღვრის 
(მინიჭების) ოპერაციას. აღწერილი ცვლადი
მოქმედებს {% endwith %} ბრძანებამდე.
✲ html ფაილში უნდა მოვახდინოთ შესაბამის ადგილას სასურველი მესიჯის 
გამოტანა

flash(‘მონაცემი დამატებულია') flash('მონაცემი დამატებულია', 'info')

{% with messages = get_flashed_messages() %}
{% for msg in messages %}
<p>{{ msg }}</p>
{% endfor %}
{% endwith %}

✲ შესაძლებელია ასევე კატეგორიის სახელის წამოღებაც
{% with messages = get_flashed_messages(with_categories=true) %}
{% for category, msg in messages %}
<p class="{{category}}">{{ msg }}</p>
{% endfor %}
{% endwith %}

✲ შესაძლებელია კონკრეტული კატეგორიის მესიჯების წამოღება. ასეთ შემთხევაში 
get_flashed_messages()
ფუნქციაში უნდა მივუთითოთ category_filter პარამეტრი შემდეგნაირად: 
get_flashed_messages(category_filter=["info"])
✲ იხილეთ შესაბამისი მაგალითები საკლასო ფაილში.
